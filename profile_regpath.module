<?php

/**
 * @file
 * Attach profile form to registration form according to path.
 *
 * @todo Create tests
 * @todo Make profile_regpath settings exportable via CTools.
 */

/**
 * Implements hook_menu().
 */
function profile_regpath_menu() {
  $items = array();

  $reg_paths = profile_regpath_regpath_load_all();

  if ($reg_paths) {
    // Set menu items for each registration path.
    foreach ($reg_paths as $reg_path) {
      $path = $reg_path->path;

      // Add profile-specific administrative 'add user' page.
      $items['admin/people/p2rp-create/' . $path] = array(
        'title' => 'Add user (' . profile_regpath_get_profile_label($reg_path->profile_type) . ' profile)',
        'page callback' => '_profile_regpath_user_register',
        'page arguments' => array(
          'regpath' => $reg_path,
        ),
        'access arguments' => array('administer users'),
        'type' => MENU_LOCAL_ACTION,
        'file' => 'registration_form.inc',
      );

      // Create registration pages for each profile type.
      // We will use hook_menu_alter() to deal with the 'user/' path later.
      if ($path != 'user') {
        $registration_path = $path . '/register';

        $items[$registration_path] = array(
          'title' => 'Create new account',
          'page callback' => '_profile_regpath_user_register',
          'page arguments' => array(
            'regpath' => $reg_path
          ),
          'access callback' => 'user_register_access',
          'file' => 'registration_form.inc',
          'type' => MENU_LOCAL_TASK,
        );
        $items[$path] = array(
          'title' => 'Log in',
          'page callback' => '_profile_regpath_user_login',
          'page arguments' => array(
            'regpath' => $reg_path,
          ),
          'access callback' => 'user_is_anonymous',
          'file' => 'registration_form.inc',
          'menu_name' => 'user-menu',
          'type' => MENU_CALLBACK,
        );
        $items[$path . '/login'] = array(
          'title' => 'Log in',
          'page callback' => '_profile_regpath_user_login',
          'page arguments' => array(
            'regpath' => $reg_path,
          ),
          'access callback' => 'user_is_anonymous',
          'file' => 'registration_form.inc',
          'type' => MENU_DEFAULT_LOCAL_TASK,
        );
        $items[$path . '/password'] = array(
          'title' => 'Request new password',
          'type' => MENU_LOCAL_TASK,
          'page callback' => '_profile_regpath_user_password',
          'page arguments' => array(
            'regpath' => $reg_path,
          ),
          'access callback' => 'user_is_anonymous',
          'file' => 'registration_form.inc',
        );
      }
    }
  }
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function profile_regpath_menu_alter(&$items) {
  // Check to see if the default 'user' path is being used with profile.
  if ($user_paths = profile_regpath_regpath_load_multiple(array('path' => 'user'))) {
    $regpath = array_shift($user_paths);
    // Build form at user/register using _profile_regpath_user_register().
    $items['user/register']['page callback'] = '_profile_regpath_user_register';
    $items['user/register']['page arguments'] = array('regpath' => $regpath);
    $items['user/register']['file'] = 'registration_form.inc';
    $items['user/register']['file path'] = backdrop_get_path('module', 'profile_regpath');

    return $items;
  }
}

/**
 * Implements hook_permission().
 */
function profile_regpath_permission() {
  $permissions = array(
    'administer profile_regpath' => array(
      'title' => t('Administer profile registration paths'),
      'description' => t('Enable and configure unique registration paths per profile profile type.'),
    ),
  );

  return $permissions;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function profile_regpath_form_profile_type_form_alter(&$form, &$form_state, $form_id) {
  module_load_include('inc', 'profile_regpath', 'profile_regpath.admin');
  _profile_regpath_form_profile_type_form_alter($form, $form_state, $form_id);
}

/**
 * Implements hook_profile_type_delete().
 */
function profile_regpath_profile_type_delete($type) {
  // Delete config entries for deleted profile profile type.
  // db_delete('profile_regpath')->condition('profile_id', $type->id)->execute();
  config('profile.regpath.' . $type)->delete();
}

/**
 * Implements hook_form_alter().
 */
function profile_regpath_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'user_register_form') {
    module_load_include('inc', 'profile_regpath');

    // Logintoboggan might display user_register_form on 403 pages.
    if (module_exists('logintoboggan') && variable_get('site_403') == 'toboggan/denied' && strpos(backdrop_get_http_header('Status'), '403') === 0) {
      $profile_types = profile_regpath_get_profiles('user');
    }
    else {
      // Get profile profile types from current path.
      $url = backdrop_parse_url($form['#action']);
      $path = ltrim($url['path'], '/');

      // Check to see if this is an alias. If so, use source path.
      if ($source = backdrop_lookup_path('source', $path)) {
        $path = $source;
      }

      // Grab first part of URL.
      $path_parts = explode('/', $path);
      $path_key = reset($path_parts);

      // Load profiles for this path key and attach associated fields.
      $profile_types = profile_regpath_regpath_load_multiple(array('path' => $path_key, 'status' => 1));
    }
    profile_regpath_attach_profile_fields($form, $form_state, $form_id, $profile_types);
  }
}

/**
 * Implements hook_user_insert().
 */
function profile_regpath_user_insert(&$edit, $account, $category) {
  // Show custom confirmation message.
  if (isset($_SESSION['profile_regpath']['confirmation_message'])) {
    backdrop_set_message(filter_xss($_SESSION['profile_regpath']['confirmation_message']));
    unset($_SESSION['profile_regpath']['confirmation_message']);
  }
}

/**
 * Provides profile_id by profile machine_name.
 *
 * @param string $profile_type
 *   Machine-name of profile profile type.
 *
 * @return string
 *   The profile id for indicated profile type.
 */
function profile_regpath_get_profile_id($profile_type) {
  $profile_id = db_query("SELECT id FROM {profile_type} WHERE type = :profile_type", array(':profile_type' => $profile_type))->fetchField();
  return $profile_id;
}

/**
 * Returns object containing all p2rp data.
 *
 * @param string $path
 *   (optional) path value for WHERE condition. Defaults to NULL.
 *
 * @param string $groupby
 *   (optional) field to groupby. Defaults to NULL.
 *
 * @return object
 *   An object containing all matching profile registration path enabled
 *   profile types.
 */
function profile_regpath_get_profiles($path = NULL, $groupby = NULL, $pid = NULL) {
  // Get data object of all registration paths.
  $query = db_select('profile_regpath', 'pr');
  $query->join('profile_type', 'pt', 'pr.profile_id = pt.id');
  $query->fields('pr', array('path', 'roles', 'misc', 'status'));
  $query->fields('pt', array('id', 'label', 'type'));
  if ($path) {
    $query->condition('path', $path);
  }
  if ($groupby) {
    $query->groupBy($groupby);
  }
  if ($pid) {
    $query->condition('profile_id', $pid);
  }
  $query->condition('pr.status', 1);
  $query->orderBy('pr.weight', 'ASC');
  $result = $query->execute();
  $profile_types = $result->fetchAll();

  return $profile_types;
}

/**
 * Provides label by profile machine_name.
 *
 * @param string $profile_type
 *   Machine-name of profile profile type.
 *
 * @return string
 *   The label for indicated profile type.
 */
function profile_regpath_get_profile_label($profile_type) {
  $profile = config_get('profile.type.' . $profile_type);
  $profile_label = $profile->label;
  return $profile_label;
}

/**
 * Implements 'load' callback for regpath exportables.
 */
function profile_regpath_regpath_load($profile_type) {
  $results = profile_regpath_load_all_config_items();
  if (isset($result[$profile_type])) {
    return $result[$profile_type];
  }
}

/**
 * Implements 'load multiple' callback for regpath exportables.
 */
function profile_regpath_regpath_load_multiple($conditions) {
  $results = profile_regpath_load_all_config_items();
  foreach ($results as $index => $config) {
    foreach ($conditions as $key => $value) {
      if (!isset($config[$ey]) || ($config[$key] != $value)) {
        unset($results[$index]);
      }
    }
  }
  return array_filter($results);
}

/**
 * Implements 'load all' callback for regpath exportables.
 */
function profile_regpath_regpath_load_all() {
  $results = profile_regpath_load_all_config_items();
  return array_filter($results);
}

/**
 * Save a single regpath.
 */
function profile_regpath_regpath_save(&$regpath) {
  $exist = profile_regpath_regpath_load($regpath['profile_type']);
  $update = $exist ? 'profile_type' : array();

  // Check if we have profile id when creating new regpath
  if (!$update) {
    // We are creating new profile type
    if (!isset($regpath['profile_id']) || !is_numeric($regpath['profile_id']) || $regpath['profile_id'] <= 0) {
      // Unvalid profile id
      // New profile type need profile id, we load it from database
      $profile_type = profile_type_load($regpath['profile_type']);

      if (empty($profile_type)) {
        // No profile types was found
        return FALSE;
      } else {
        $regpath['profile_id'] = $profile_type->id;
      }
    }
  }

  return db_merge('profile_regpath')->key(array('profile_type' => $regpath['profile_type']))->fields($regpath)->execute();
}

/**
 * Delete a regpath.
 */
function profile_regpath_regpath_delete($regpath) {
  // Prevent "Call to undefined function ctools_include()" error
  module_load_include('module', 'ctools', 'ctools');

  $profile_type = is_object($regpath) ? $regpath->profile_type : $regpath;
  db_query('DELETE FROM {profile_regpath} WHERE profile_type=:profile_type', array(':profile_type' => $profile_type));

  // Clear the Ctools export API cache.
  ctools_include('export');
  ctools_export_load_object_reset('profile_regpath');
}

/**
 * Implements hook_features_revert().
 * Rebuild menu after all profile_regpath components is reverted.
 *
 * @param type $module_namestring $module_name
 *   The name of the feature module whose components should be reverted.
 */
function profile_regpath_features_revert($module_name) {
  return profile_regpath_features_rebuild($module_name);
}

/**
 * Implements hook_features_rebuild().
 * Rebuild menu after all profile_regpath components is re-built.
 *
 * @param string $module_name
 *   The name of the feature module whose components should be rebuilt.
 */
function profile_regpath_features_rebuild($module_name) {
  $regpaths = module_invoke($module_name, 'default_profile_regpath');
  if (!empty($regpaths)) {
    foreach ($regpaths as $regpath) {
      // Disable non-schema properties
      unset($regpath->disabled);
      unset($regpath->api_version);
      $regpath = get_object_vars($regpath);
      $profile = profile_type_load($regpath['profile_type']);
      $regpath['profile_id'] = $profile->id;
      profile_regpath_regpath_save($regpath);
    }
  }
  menu_rebuild();
}


/**
 * Load all configuration files with registration ppaths.
 * @return array Array with loaded configs.
 */
function profile_regpath_load_all_config_items() {
  $items = &backdrop_static(__FUNCTION__);
  if (isset($items)) {
    return $items;
  }

  $items = array();
  $config_names = config_get_names_with_prefix('profile.regpath.');
  foreach ($config_names as $config_name) {
    $item = config_get($config_name);
    $items[$item['profile_type']] = $item;
  }
  return $items;
}
